<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/app-storage/app-localstorage/app-localstorage-document.html">

<link rel="import" href="log-behavior.html">

<dom-module id="line-chart-item">
  <template strip-whitespace>
    <app-localstorage-document key="[[id]]" data="{{dataset.data}}" log$={{verbose}}></app-localstorage-document-->
  </template>
  <script>
    Polymer({
      is: 'line-chart-item',
      behaviors: [
        AppBehaviors.LogBehavior
      ],
      properties: {
        labels: {
          type: Array,
          notify: true
        },
        dataset: {
          type: Object,
          notify: true
        },
        options: {
          type: Object,
          value: null
        },
        lastMessage: {
          type: Object,
          notify: true,
          observer: '_processMessage'
        }
      },
      ready: function() {
        this.async(function() {
          // set dataset options if available - http://www.chartjs.org/docs/#line-chart-dataset-structure
          if (this.options !== null) {
            this._log('Setting dataset options: ', this.options);
            // copy all properties
            for (property in this.options) {
              this.dataset[property] = this.options[property];
            }
          }
        });
      },
      /**
       * process incoming messages
       */
      _processMessage: function(message) {
        if (message) {
          this.async(function() {
            var interpolate = false;
            // create Label object
            var label = new Label(message.timestamp);
            // search for next last label entry
            var index = this._firstIndexOf(label);
            // if label isn't available push new label to x-axis -- don't care of any natural (re-)order
            if (index === -1) {
              // while value limit is reached, shift labels & dataset to gain new space(s);
              // use 'while' instead of 'if' to reduce a serialized array afterwards
              while (this.labels.length >= this.dataset.valueLimit) {
                this.shift('labels');
                this.shift('dataset.data');
              }
              // push a new label to the labels end
              this.push('labels', label);
              index = this.labels.length - 1;
              // force interpolation for sibling elements
              interpolate = true;
            } else {
              // update label
              console.log("hey update label ...." + label);
              this.set('labels' + index, label);
            }
            // push value at corresponding index
            this._log("Setting dataset.data." + index + ": " + message.value + " at label: " + this.labels[index]);
            this.set('dataset.data.' + index, message.value);
            // notify parent element
            this.fire('chart-update', {'id': this.id, 'interpolate': interpolate});
          });
        }
      },
      interpolate: function() {
        var path = 'dataset.data';
        // while value limit is reached, shift dataset to gain new space
        // use 'while' instead of 'if' to reduce a serialized array afterwards
        while (this.dataset.data.length >= this.dataset.valueLimit) {
          this.shift(path);
        }
        // interpolate with latest known value
        this.push(path, this.dataset.data[this.dataset.data.length - 1]);
      },
      /**
        * return the first index at which the label is in an equal value range, or -1 if it isn't present
        */
      _firstIndexOf: function(label) {
        var index = -1;
        // search x-axis for the first entry that is in an equal value range
        for (var i = 0; i < this.labels.length; i++) {
          // break if a similar timestamp is found
          var until = this.labels[i].timestamp + this.dataset.valueRange;
          if (label.timestamp <= until) {
            this._log("Matching label ", new Label(label.timestamp), "is before or equal ", new Label(until));
            index = i;
            break;
          }
        }
        return index;
      },
      /**
        * return the last index at which the label is in an equal value range, or -1 if it isn't present
        */
      _lastIndexOf: function(label) {
        var index = -1;
        // search x-axis backward for the first entry that is in an equal value range
        for (var i = this.labels.length - 1; i > -1; i--) {
          var until = this.labels[i].timestamp + this.dataset.valueRange;
          if (label.timestamp <= until) {
            this._log("Matching label ", new Label(label.timestamp), "is before or equal ", new Label(until));
            index = i;
            break;
          }
        }
        return index;
      }
    });
  </script>
</dom-module>
